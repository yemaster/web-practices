name: Build and Push Docker Images

on:
  push:
    paths:
      - '*/**/*' # Trigger on changes to any file in second-level folders
      - '!*/README.md' # Ignore changes to README files in chapter folders
      - '!*.md' # Ignore changes to top-level markdown files

jobs:
  build-and-push:
    runs-on: ubuntu-latest

    steps:
      # Checkout the repository
      - name: Checkout code
        uses: actions/checkout@v4

      # Get changed files
      - name: Get changed files
        id: changed-files
        uses: tj-actions/changed-files@v45
        with:
          files: |
            */**/*
          files_ignore: |
            **/README.md
            *.md
          json: true

      # Set up Docker Buildx
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      # Log in to the container registry
      - name: Log in to registry
        uses: docker/login-action@v3
        with:
          registry: registry.abstrax.cn
          username: ${{ secrets.REGISTRY_USERNAME }}
          password: ${{ secrets.REGISTRY_PASSWORD }}

      # Extract unique problem folders from changed files
      - name: Extract problem folders
        id: changed-folders
        run: |
          changed="${{ steps.changed-files.outputs.all_changed_files }}"
          echo "RAW changed files: >>>$changed<<<" >&2

          problem_folders=$(echo "$changed" | jq -r '.[]' | while read -r file; do
              if [[ $file =~ ^web[0-9a-zA-Z_]+-[^/]+/[0-9a-zA-Z_]+-[^/]+ ]]; then
                  # 提取匹配的文件夹路径部分
                  echo "$file" | sed -E 's|^(web[0-9a-zA-Z_]+-[^/]+/[0-9a-zA-Z_]+-[^/]+).*$|\1|'
              fi
          done | sort -u | jq -R . | jq -s -c .)

          echo "Extracted problem folders: $problem_folders" >&2
          escaped_problem_folders=$(echo "$problem_folders" | sed 's/"/\\"/g')

          echo "problem_folders=$escaped_problem_folders" >> $GITHUB_OUTPUT
        shell: bash

      # Process each changed problem folder
      - name: Build and push Docker images
        id: build-and-push
        if: steps.changed-folders.outputs.problem_folders != '[]'
        env:
          REGISTRY: registry.abstrax.cn
        run: |
          images=()

          # Loop through changed problem folders
          problem_folders="${{ steps.changed-folders.outputs.problem_folders }}"
          echo "Processing problem folders: $problem_folders" >&2
          for folder in $(echo "$problem_folders" | jq -r '.[]'); do
            config_file="$folder/config.yaml"
            echo "Processing folder: $folder" >&2
            if [ -f "$config_file" ]; then
              is_docker=$(yq '.type == "docker"' "$config_file")
              if [ "$is_docker" = "true" ]; then
                chapter=$(echo "$folder" | cut -d'/' -f1 | grep -oE 'web[0-9a-zA-Z_]+' | sed 's/web//')
                problem=$(echo "$folder" | cut -d'/' -f2 | grep -oE '^[0-9a-zA-Z_]+')
                image_name="yemaster/web$chapter-$problem"
                echo "Building Docker image for $folder ($image_name)"
                
                docker build -t "$REGISTRY/$image_name" "$folder/challenge"
                docker push "$REGISTRY/$image_name"

                images+=("$image_name")
              else
                echo "Skipping $folder: Not a docker type"
              fi
            else
              echo "Skipping $folder: No config.yaml found"
            fi
          done
        
          # 传递 images 到下一个步骤
          if [ ${#images[@]} -eq 0 ]; then
            images_json="[]"
          else
            images_json=$(printf '%s\n' ${images[@]} | jq -R . | jq -s -c .)
          fi
          echo "Built and pushed images: $images_json" >&2
          escaped_images_json=$(echo "$images_json" | sed 's/"/\\"/g')
          echo "images=$escaped_images_json" >> $GITHUB_OUTPUT
      
      # Send the notification
      - name: Send Notification
        if: steps.build-and-push.outputs.images != '[]' && steps.build-and-push.outputs.images != ''
        env:
          API_URL: ${{ secrets.NOTIFY_API_URL }}
          API_KEY: ${{ secrets.NOTIFY_API_KEY }}
        run: |
          images="${{ steps.build-and-push.outputs.images }}"
          echo "Images to notify: $images" >&2
          curl -X POST "$API_URL" \
            -H "Content-Type: application/json" \
            -H "X-API-Key: $API_KEY" \
            -d "{\"images\": $images}"
        shell: bash
          
